\section{Procedure a supporto dei processi} \label{procedure}
Le seguenti norme regolano i processi principali del ciclo di vita del software. Ogni ruolo di progetto è tenuto a seguirli per il raggiungimento degli obiettivi fissati nel \textit{Piano di Qualifica.}

\subsection{Gestione di Progetto}
La gestione del progetto, dalla nascita alla conclusione, spetta al \ruoloResponsabile . Egli ha il compito di:
\subsubsection{Pianificazione delle attività}
\textit{(Pianificare in anticipo le attività e tenere traccia del loro corretto svolgimento)} \\ \\
Questa attività è eseguita attraverso lo studio dei processi e la stima delle ore richieste per portare a termine le attività da cui sono composti. Servirsi dei dati ricavati dalle attività compatibili già portate a termine dal gruppo o, quando non presenti, utilizzare dati provenienti da fonti esterne attendibili. \\
Una volta creato un piano di lavoro per una macro-fase, il \ruoloResponsabile{}  deve realizzare un diagramma di Gantt$_G$ con il software ProjectLibre$_G$, il cui compito è quello di mostrare la distribuzione temporale delle attività. Il calcolo delle ore viene invece eseguito con l'aiuto di un foglio elettronico; per questo scopo è stato realizzato un template$_G$, disponibile nella Repository$_G$ del progetto. Tutte informazioni ricavate devono essere disponibili all'interno del \textit{Piano di Progetto}, che dovrà essere sempre aggiornato e riportare ogni modifica effettuata sulla pianificazione delle attività.

\subsubsection{Assegnare attività a risorse}
\textit{(Collocare e gestire le risorse necessarie e sufficienti allo svolgimento delle attività)}\\ \\
Per l'assegnazione delle attività alle risorse, e per il controllo periodico del loro progresso, il \ruoloResponsabile{} ha a disposizione il sistema di ticketing$_G$ di GitHub, descritto nella sezione \ref{procedureticket}.
\subsubsection{Studio dei rischi}
\textit{(Studiare i possibili rischi a cui il progetto puo' andare incontro, controllare periodicamente la possibilità che si verifichino e gestire quelli che si sono verificati)}\\ \\
I rischi, il loro grado di pericolosità, la loro probabilità di avverarsi e le contromisure da adottare per prevenirli o correggerli vengono descritti in dettaglio nel \textit{Piano di Progetto}.
Tutte queste attività devono essere il più possibile automatizzate o supportate da strumenti in grado di tenere traccia dei compiti portati a termine. Tali strumenti vengono descritti nella sezione \ref{ambientedilavoro}.


\subsection{Analisi dei Requisiti}
\subsubsection{Studio di Fattibilità}
In seguito alla scelta del capitolato da parte del gruppo è necessario che gli \textit{Analisti} redigano uno \textit{Studio di Fattibilità}. Questo documento dovrà focalizzarsi su:
\begin{itemize}
\item \textbf{Dominio applicativo e tecnologico:} la conoscenza, da parte dei componenti del gruppo, del dominio applicativo e delle tecnologie richieste nel capitolato scelto; 
\item \textbf{Guadagno:} rapporto tra costi per la realizzazione e dei benefici ricavati dal prodotto completo;
\item \textbf{Analisi dei rischi:} individuazione dei rischi derivati da lacune di conoscenza del dominio e dalle tecnologie richieste;
\item \textbf{Confronto con gli altri capitolati}: elenco delle ragioni che hanno portato a scartare gli altri capitolati.
\end{itemize}
\subsubsection{Requisiti}
In seguito allo studio di fattibilità gli \textit{Analisti} dovranno identificare e classificare i Requisiti. \\
I Requisiti devono essere individuati attraverso lo studio delle seguenti fonti:
\begin{itemize}
\item il capitolato d'appalto;
\item il dominio applicativo;
\item i documenti ufficiali del committente;
\item i resoconti dell'interazione col fornitore (vedi \ref{collaborazioneriunioniesterne});
\item i resoconti delle riunioni con il committente;
\item i resoconti delle riunioni di gruppo (brainstorming$_G$);
\item la prototipazione di alcune parti del prodotto;
\end{itemize}
La classificazione verrà operata sui seguenti attributi:
\begin{itemize}
\item \textbf{Tipo del Requisito} i cui valori possono essere:
\begin{itemize}
\item[F] Funzionale;
\item[Q] di Qualità;
\item[V] di Vincolo;
\item[P] Prestazionale.
\end{itemize}
\item \textbf{Valore del Requisito} i cui valori possono essere:
\begin{itemize}
\item[Ob] Obbligatorio;
\item[De] Desiderabile;
\item[Op] Opzionale.
\end{itemize}
\item \textbf{Codice univoco} è il codice espresso in modo gerarchico come segue.
\begin{center}
[codice del padre].[numero unico rispetto ai fratelli]
\end{center}
\end{itemize} 
Oltre a questa classificazione è necessario aggiungere una breve descrizione ad ogni requisito
\subsubsection{Casi d'Uso}
In seguito alla classificazione dei requisiti gli \textit{Analisti} dovranno identificare i \textit{casi d'uso} o \textit{use case}.
Di ogni caso d'uso interessa:
\begin{itemize}
\item \textbf{Titolo} breve titolo che identifica lo UC;
\item \textbf{Pre e Post Condizione};
\item \textbf{Attori} principali e secondari;
\item \textbf{Scenari} principali e alternativi definendo per ognuno titolo, attori coinvolti, una breve descrizione e il caso d'uso a cui si riferiscono se presente;
\item \textbf{Descrizione} breve descrizione dello UC;
\item \textbf{Requisiti Dedotti}.
\end{itemize} 
\subsubsection{Tracciamento}
I requisiti, i casi d'uso e le fonti dovranno essere inseriti, dagli \textit{Analisti}, in un database$_G$ appositamente creato. Per facilitare le operazioni necessarie è stata creata un'applicazione web il cui nome è 404TrackerDB.
Compito dell'applicazione è anche quella di creare il codice {Latex}, sia delle tabelle per il tracciamento sia delle generalità di fonti e requisiti, in modo automatico per velocizzare la stesura del documento \textit{Analisi dei Requisiti}. 


\subsection{Progettazione Architetturale}
È compito dei \textit{Progettisti} studiare la struttura dei componenti più adatta a soddisfare i requisiti tracciati nella fase di Analisi. \\
La progettazione dovrebbe essere il più possibile indipendente dai linguaggi di programmazione e dagli ambienti di sviluppo che verranno adottati nella fase di codifica del software, a meno che non vengano richiesti esplicitamente dal proponente.
\subsubsection{Specifica Tecnica}
Il documento che raccoglie le informazioni ricavate durante la progettazione architetturale è la \textit{Specifica Tecnica}, e deve essere composto dalle seguenti sezioni:
\begin{itemize}
\item \textbf{Tecnologie Utilizzate:} Devono essere esposte le tecnologie ed i design pattern$_G$ su cui si basa la progettazione del software.
\item \textbf{Descrizione dell'Architettura:} l'architettura generale del sistema deve essere introdotta da una breve descrizione dei metodi e formalismi di specifica adottati durante la fase di progettazione, con particolare attenzione ad eventuali dipendenze dall'ambiente di sviluppo adottato.
\item \textbf{Diagrammi dei Package:} I componenti devono essere rappresentati da package$_G$ che definiscono i namespace$_G$ per le classi, le librerie o gli oggetti da cui saranno composti. Ogni componente deve essere rappresentata seguendo lo standard UML$_G$ 2.0, e seguita da una descrizione che indichi la propria funzione all'interno del software, ed eventuali dipendenze con altri componenti. Package$_G$ e classi interne devono essere citate con la seguente notazione: \\
\verb|PackageEsterno.PackageInterno.Classe|

\item\textbf{Descrizione dei singoli componenti:} Ogni elemento proprio del software presente all'interno di un componente deve essere descritto nel modo seguente:
\begin{itemize}
\item \textbf{Nome:} della classe o dell'elemento
\item \textbf{Tipo:} classe, classe anonima, etc.
\item \textbf{Package:} di appartenenza, con la notazione scritta sopra
\item \textbf{Descrizione:} della classe e delle funzionalità che mette a disposizione
\item \textbf{Relazioni con altri componenti:} Dipendenze, associazioni, relazioni di ereditarietà o implementazione secondo la notazione UML2.0$_G$.
\end{itemize}
Suddividere le classi per package e accompagnare ogni package da un Diagramma delle Classi utilizzando la notazione UML$_G$ 2.0. Evidenziare in particolar modo le relazioni di dipendenza, sia interne che esterne.
\item \textbf{Diagrammi delle attività:}
Le azioni che l'utente puo' compiere attraverso i componenti, e la logica procedurale del software, devono essere descritti tramite i Diagrammi delle Attività secondo la notazione UML$_G$ 2.0. Anche qui ogni diagramma dovrà essere accompagnato da una breve descrizione degli obiettivi che l'attività si propone di raggiungere.
\item \textbf{Stime di Fattibilità:} In questa sezione viene appurata la conformità e l'efficienza delle tecnologie utilizzate per lo sviluppo del software.
\item \textbf{Tracciamento delle relazioni classi-requisiti:} Ogni classe, ed eventualmente ogni componente, deve corrispondere alla soddisfazione di uno o più requisiti, o di parte di essi. Allo stesso tempo ogni requisito deve poter essere soddisfatto da una o più classi o componenti. L'applicazione 404TrackerDB si occuperà di creare il codice Latex delle relazioni inserite nella sua base di dati, e di verificare che tali norme vengano rispettate.
\item \textbf{Design Pattern:} Ogni design pattern$_G$ utilizzato per costruire l'architettura del software deve essere descritto in dettaglio in questa sezione apposita, in modo da fornire ai membri del gruppo e ai lettori del documento una fonte sempre disponibile delle informazioni necessarie a capire i componenti ed il loro modo di interagire con il resto del software.
\end{itemize}

\subsection{Progettazione di Dettaglio}


\subsubsection{Definizione di Prodotto}
È compito dei \textit{Progettisti} utilizzare quanto scritto nella \textit{Specifica Tecnica} per produrre la \textit{Definizione di Prodotto} dove viene descritta la
progettazione di dettaglio del sistema. Lo scopo di questo documento è quello di definire dettagliatamente ogni singola unità di cui è composto il sistema in modo da semplificare l’attività di codifica e allo stesso tempo di non fornire alcun grado di libertà al \ruoloProgrammatore.

\paragraph{5.5.1.1 Diagrammi UML \\}

Devono essere redatti i seguenti diagrammi:

\begin{itemize}
	\item diagrammi delle classi;
	\item diagrammi di attività;
	\item diagrammi di sequenza.
\end{itemize}

\paragraph{5.5.1.2 Definizione di classe \\}
Ogni classe progettata deve essere descritta all’interno della “Definizione di
Prodotto”. Tale descrizione deve comprendere una spiegazione sullo scopo della classe e
deve specificare quale funzionalità essa modella. Nella descrizione devono inoltre essere
presenti l’elenco di metodi e attributi della classe.
La descrizione di ogni classe deve essere composta da:

\begin{itemize}

\item \textbf{Diagramma della Classe:} secondo il formalismo UML$_G$ 2.0;
\item \textbf{Classi ereditate:} la gerarchia a cui appartiene la classe;
\item \textbf{Attributi:} propri della classe, con una lista formata da: \\ \textit{Nome} scritto come \verb|accesso nome : tipo|, \textit{Accesso}, \textit{Tipo}, \textit{Descrizione};
\item \textbf{Metodi:} propri della classe o ridefiniti, con una lista formata da: \\ \textit{Nome} scritto come \verb|accesso nome(tipoAtt1 attributo1) : tipoRitorno|, \textit{Accesso}, \textit{Tipo di ritorno}, \textit{Parametri}, \textit{Descrizione}
\end{itemize}

\paragraph{5.5.1.3 Tracciamento requisiti - classi \\}
Ogni classe deve soddisfare un requisito o parte di esso. Allo stesso tempo ogni requisito deve essere soddisfatto da una o più classi.
Le classi vanno inserite nel database gestito dal software 404TrackerDB, il quale si occuperà di verificare la soddisfacibilità dei requisiti e di generare il codice {Latex} appropriato.

\paragraph{5.5.1.4 Test di unità \\}
Durante la \textit{Progettazione di Dettaglio} i \textit{Progettisti} hanno inoltre il compito di definire i test di unità per assicurarsi che i componenti realizzati siano privi di difetti.

\subsection{Verifica}

La verifica di processi, documenti e prodotti è un'attività da eseguire continuamente
durante lo sviluppo del Progetto. Di conseguenza, servono modalità operative chiare
e dettagliate, in modo da uniformare le attività di verifica svolte ed
ottenere il miglior risultato possibile. Si descrivono ora le modalità di verifica di processi, documenti, attività e codice alle quali ci si riferirà in questo
documento e alle quali i Verificatori dovranno attenersi.

\subsubsection{Verifica dei documenti}
Il processo di verifica viene istanziato nel momento in cui l'output di un processo passa
dalla versione X.Y alla versione X+1.0. È compito del \ruoloResponsabile\ notificare i Verificatori dell'inizio dell'attività di verifica. Attraverso il diario delle modifiche è
possibile focalizzare l'attenzione maggiormente sulle sezioni che hanno subito dei cambiamenti dall'ultima verifica, riducendo il tempo necessario al controllo.
Per eseguire un'accurata verifica dei documenti redatti è necessario seguire il seguente
protocollo:

\begin{enumerate}
	\item \textbf{Controllo sintattico del periodo:} Utilizzando TeXMaker$_G$ vengono
evidenziati gli errori ortografici. Gli errori di sintassi, di sostituzione di lettere che provocano la creazione di parole grammaticalmente corrette ma sbagliate nel contesto ed i periodi di difficile comprensione necessitano dell'intervento di un verificatore umano. Per questa ragione ciascun documento dovrà essere sottoposto ad un walkthrough da parte dei verificatori per individuare tali errori;
	\item \textbf{Rispetto delle norme di progetto:} In questo documento sono state definite norme tipografiche di carattere generale. Queste regole impongono una struttura dei documenti che non può essere verificata in maniera automatica, di conseguenza è necessario che i
	\ruoloVerificatore\ esegua inspection sul rispetto di quelle norme in ciascun documento;
	\item \textbf{Verifica delle proprietà di glossario:} Il \ruoloVerificatore\ dovrà controllare che per ogni termine contrassegnato come definito nella sezione 3.8 sia presente la definizione corrispondente all'interno del Glossario;
	\item \textbf{Miglioramento del processo di verifica:} Per avere un miglioramento del
processo di verifica, quando il \ruoloVerificatore\ utilizza la tecnica walkthrough su un documento, dovrà riportare gli errori più frequenti, per consentire l'utilizzo di inspection su tali errori nelle verifiche future;

\end{enumerate}

\subsubsection{Verifica dei diagrammi UML}
Al \ruoloVerificatore\ è richiesto il controllo dei diagrammi UML$_G$ prodotti:

\begin{itemize}
 	\item \textbf{Diagrammi dei casi d'uso:} Il \ruoloVerificatore\ deve controllare il rispetto delle specifiche UML$_G$ 2.4 e il corretto uso delle relazioni di inclusione ed estensione. Il diagramma di caso d'uso deve rappresentare fedelmente quanto descritto dal caso d'uso;
	\item \textbf{Diagrammi delle classi:} Il \ruoloVerificatore\ ha il compito di controllare il rispetto del formalismo UML$_G$ 2.0 e la corrispondenza tra progettazione e diagrammi delle classi.
\end{itemize}

\subsubsection{Verifica del codice}
Per la verifica del codice al \ruoloVerificatore\ è richiesto l'avvio dei test statici e dinamici riportati nella sezione 2.5.2 del \textit{PianoDiQualifica\_v2.0.pdf} e l'analisi dei risultati ottenuti.

\subsubsection{Gestione delle anomalie}

Lo strumento scelto per la gestione delle anomalie è la sezione ``Issue'' messa a disposizione da Github$_G$. Coerentemente con l'organizzazione generale delle strategie di verifica, nuove anomalie potranno essere scoperte in due modi:

\begin{itemize}
	\item In ogni fase di verifica, il \ruoloVerificatore\ avrà il compito di cercare eventuali anomalie;
	\item Grazie all'approccio ``Broken Window Theory'' (\textit{PianoDiQualifica\_v2.0.pdf} sezione 2.1), chiunque in qualunque momento è incentivato alla ricerca di possibili anomalie.
\end{itemize}
Nel caso in cui un \ruoloVerificatore\ o un membro del gruppo individui un anomalia dovrà segnalarlo aprendo un ticket$_G$ (vedi sezione 5.2). Un \ruoloVerificatore\ ha il compito di controllare le pull request quindi nel caso trovasse un anomalia deve impedire la pull request con le modalità descritte nella sezione 5.4.

\subsection{Codifica}
\subsubsection{Codifica e convenzioni}
\begin{itemize}
	\item Tutti i file contenenti codice o documentazione devono essere conformi alla codifica UTF$_G$-8 senza BOM$_G$ (poiché potrebbe causare problemi nella verifica). Per andare a capo viene usato il carattere LF$_G$ (U+000A).
	\item È ammessa la possibilità di effettuare modifiche alle convenzioni stabilite, in seguito ad una decisione del \ruoloResponsabile .
\end{itemize}

\subsubsection{Nomi e norme stilistiche}
\begin{itemize}
	\item I nomi di variabili, classi, funzioni e metodi devono essere in inglese e privi di underscore;
	\item I commenti devono essere scritti in lingua italiana;
	\item I nomi delle classi devono avere la prima lettera maiuscola;
	\item I nomi di variabili, metodi e funzioni devono avere la prima lettera minuscola e le successive iniziali delle parole che ne compongono il nome, in maiuscolo.
\end{itemize}

\subsubsection{Ricorsione}
La ricorsione va evitata quando possibile. Per ogni funzione ricorsiva è necessario
fornire una prova di terminazione. È inoltre necessario valutare il costo in termini di
occupazione della memoria. Nel caso in cui l’utilizzo di memoria risulti troppo elevato, la ricorsione verrà rimossa.

\subsubsection{Intestazione File}
Tutti i file di codice sorgente devono iniziare con la seguente intestazione:
\color{blue}\begin{lstlisting}[frame=single]
/**	
	* Name: 		[nome del file]
	* Package: 		[directory completa]
	* Author: 		[creatore del file]
	* Date: 		AAAA-MM-GG [data di creazione del file]

	* Use:
	[cosa fa questo file??]
	
	* Changes:
	Version		Date		Who 			Changes				Reason
	----------------------------------------------------------------------------
	[x].[y]		AAAA-MM-GG					[cambiamento]		[motivazione]
	----------------------------------------------------------------------------
	[x].[y]		AAAA-MM-GG					[cambiamento]		[motivazione]
	----------------------------------------------------------------------------

	* Created by 404Notfound for Premi - Better than Prezi!

	* Premi is a free software: you can redistribute it and/or modify
	* it under the terms of the GNU General Public License as published by
	* the Free Software Foundation, either version 3 of the License, or
	* (at your option) any later version.

	* This program is distributed in the hope that it will be useful,
	* but WITHOUT ANY WARRANTY; without even the implied warranty of
	* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	* GNU General Public License for more details.

	* You should have received a copy of the GNU General Public License
	* along with this program. If not, see <http://www.gnu.org/licenses/>
*/

\end{lstlisting}\color{black}
I campi andranno aggiornati ad ogni modifica del codice. Cercare di adeguarsi il più possibile alla tabulazione basilare dell'intestazione.
<<<<<<< HEAD
\begin{itemize}
\item \textbf{Name:} il nome e l'estensione del file;
\item \textbf{Package:} la directory in cui è stato inserito il file, partendo dalla cartella premi. Esempio: \texttt{premi/server/};
\item \textbf{Author:} il creatore del file.;
\item \textbf{Date:} la data di creazione del file;
\item \textbf{Use:} il perché dell'esistenza del file;
\item \textbf{Changes:} il registro delle modifiche del file. La modifica più recente si trova in cima alla lista, mentre quella meno recente alla fine:
	\begin{itemize}
		\item \textit{Version:} versione del file;
		\item \textit{Date:} data di modifica del file;
		\item \textit{Who:} chi ha modificato il file;
		\item \textit{Changes:} dove sono state effettuate le modifiche;
		\item \textit{Reason:} le ragioni della modifica.
	\end{itemize}
\end{itemize}

\subsubsection{Strumenti}
=======
>>>>>>> 1dce3b674062dea384b531dfee33e696a16e862e
\begin{itemize}
\item \textbf{Name:} il nome e l'estensione del file;
\item \textbf{Package:} la directory in cui è stato inserito il file, partendo dalla cartella premi. Esempio: \texttt{premi/server/};
\item \textbf{Author:} il creatore del file.;
\item \textbf{Date:} la data di creazione del file;
\item \textbf{Use:} il perché dell'esistenza del file;
\item \textbf{Changes:} il registro delle modifiche del file. La modifica più recente si trova in cima alla lista, mentre quella meno recente alla fine:
	\begin{itemize}
		\item \textit{Version:} versione del file;
		\item \textit{Date:} data di modifica del file;
		\item \textit{Who:} chi ha modificato il file;
		\item \textit{Changes:} dove sono state effettuate le modifiche;
		\item \textit{Reason:} le ragioni della modifica.
	\end{itemize}
\end{itemize}

\subsection{Procedure per l'utilizzo del repository} \label{procedureticket}
Vengono qui elencate le norme per l'utilizzo degli strumenti di sviluppo del sito web GitHub$_G$. \\
Per una guida completa all'uso di GitHub$_G$ si consiglia il sito: \\
\url{https://guides.github.com/}\\
Per una guida completa sull'uso di git$_G$ da terminale si consiglia il sito: \\
\url{http://git-scm.com/doc/}

\subsubsection{Creare una milestone}
La creazione di una milestone$_G$ viene affidata esclusivamente al \ruoloResponsabile\ e il suo scopo è quello di suddividere il lavoro in elenchi di attività correlate tra loro per un maggiore controllo sullo stato di avanzamento del progetto. Le attività possono essere a loro volta suddivise in compiti che vengono spartiti tra i componenti del gruppo attraverso la creazione di ticket$_G$. \\
Milestone e ticket vengono creati seguendo i calendari delle attività inseriti nel \textit{Piano di Progetto}. \\
    Dalla pagina della repository$_G$ accedere al menu \textit{issues}, andare sulla sezione \textit{Milestones} e quindi su \textit{New milestone$_G$}.\\
    Inserire un breve titolo che la distingua dalle milestone$_G$ precedenti, una descrizione approfondita che identifichi le parti del progetto su cui si sta lavorando e infine la data di chiusura.

\subsubsection{Creare un ticket}
Un ticket$_G$ corrisponde ad un compito da portare a termine all'interno di una milestone$_G$. Vengono creati dal \ruoloResponsabile\ e assegnati a sua discrezione ad un componente del gruppo. \\
Dalla pagina della repository$_G$ accedere al menu \textit{issues} e premere su \textit{New Issue}.\\
È richiesta la compilazione dei seguenti campi:
\begin{itemize}
    \item \textit{Title:} descrive sinteticamente il compito assegnato;
    \item \textit{Assigned to:} è il membro del gruppo che si occuperà del compito;
    \item \textit{Comment:} descrizione approfondita del compito. È possibile includere immagini esplicative se ritenuto necessario;
    \item \textit{Milestone$_G$:} per includere il ticket$_G$ in un contesto temporale;
    \item \textit{Labels:} aiutano a suddividere i compiti per tipo.
\end{itemize}
È possibile creare dei collegamenti ai ticket$_G$ all'interno dei commenti in GitHub$_G$ scrivendo l'id del ticket preceduto dal carattere \#.

\subsubsection{Eseguire il compito}
Per eseguire il compito assegnato, l'incaricato deve creare un branch$_G$ su cui lavorare. \\
Dalla pagina della repository$_G$ premere sul pulsante della lista dei branch$_G$ e digitare il nome del nuovo branch$_G$, che deve essere formato dal nome dell'incaricato seguito dall'id del ticket$_G$ nella forma: 
\begin{verbatim}
nome-id
\end{verbatim}
Se quello su cui si sta lavorando non dovesse essere collegato a nessun ticket$_G$ inserire, invece dell'id, un nome che identifichi il compito. \\
Viene lasciato a discrezione dell'incaricato il numero di salvataggi (commit$_G$) da effettuare. È però consigliabile salvare i files su su cui si sta lavorando nella repository$_G$ remota almeno una volta al giorno per non perdere il lavoro in caso di incidenti e in modo che il resto del gruppo possa vedere lo stato di avanzamento del compito. \\
Ogni commit$_G$ deve essere accompagnato da un breve titolo e una descrizione che elenchi quello che è stato aggiunto al branch$_G$. \\
Quando il lavoro è concluso inviare una \textit{pull request}$_G$, ossia la richiesta di riunire il branch$_G$ con l'originale. Dalla pagina della repository$_G$ accedere al menu \textit{Pull Requests}$_G$ e premere sul pulsante \textit{New pull request}; selezionare il branch$_G$ base e quello su cui si ha eseguito il compito e premere \textit{Create pull request}.\\ È richiesta la compilazione dei seguenti campi:
\begin{itemize}
    \item \textit{titolo:} deve essere il nome del branch$_G$ da riunire;
    \item \textit{commento:} deve contenere almeno l'id del ticket$_G$(\textit{issue}) del compito eseguito nella forma \texttt{\#id} e preceduto dalla parola chiave \texttt{Fixes }, per rendere automatica la chiusura del ticket una volta accettata la richiesta. 
\end{itemize}

\subsubsection{Verifica del compito}
Il \ruoloVerificatore\ ha il compito di esaminare le \textit{pull request}$_G$ proposte dai membri del gruppo.\\
Dopo aver verificato il lavoro svolto, dal menu \textit{Pull Requests}$_G$ ha tre possibilità:
\begin{itemize}
\item \textit{Accettare la richiesta:} Il lavoro è corretto e soddisfa i requisiti del compito; il branch$_G$ viene unito al \textit{master} e il ticket$_G$ viene chiuso. Questa azione viene chiamata \textit{merge}$_G$;
\item \textit{Comunicare con il richiedente:} Se il lavoro presenta degli errori o non soddisfa i requisiti del compito, il \ruoloVerificatore\ può lasciare dei commenti all'interno della \textit{pull request}$_G$ in cui descrive i problemi riscontrati. L'incaricato è tenuto a risolvere i problemi e ad aggiornare il branch$_G$;
\item \textit{Rifiutare la richiesta:} La richiesta non è pertinente al lavoro in corso e viene chiusa senza effettuare il \textit{merge}$_G$. Il \ruoloVerificatore\ è tenuto comunque a lasciare un commento che giustifichi tale azione.
\end{itemize}

\subsubsection{Chiudere una milestone}
Quando tutti i ticket$_G$ sono stati chiusi il \ruoloResponsabile\ può chiudere la milestone$_G$ in corso. \\
Dalla pagina della repository$_G$ accedere al menu \textit{issues}, andare sulla sezione \textit{Milestones} e selezionare quella che si intende chiudere; infine premere su \textit{close}.
